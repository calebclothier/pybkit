from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .operation import Operation



class ArrayCircuit:
    """ Class representing a set of tweezer sites and a set of operations acting
    on them.

    The sites are organized into site_groups for the purposes of motion planning """

    def __init__(self, idle_err=None):
        self.site_groups = []
        self.operations = []
        self.circuit = cirq.Circuit()
        self.idle_err = idle_err

    def __repr__(self):
        ret = ""
        t = 0
        for op in self.operations:
            ret += "@t=%.add2f: %s\n" % (t, op.__repr__())
            t += op.get_duration()
        return ret

    def set_idle_err(self, idle_err):
        self.idle_err = idle_err

    def append(self, op):
        if isinstance(op, Operation):
            op_list = [op]
        for op_i in op_list:
            if isinstance(op_i, Operation):
                sg = getattr(op_i, 'sg', None)
                if sg is not None:
                    if sg not in self.site_groups:
                        self.site_groups.append(sg)
            self.operations.append(op_i)

    def do(self, upto=None, error=False, states=None):
        # upto: int, last index to do
        # error: boolean, whether to include errors
        # states: list, states of this experiments, used for conditional operations
        if states is None:
            states = [0]
        # remove all operations in circuit
        try:
            for idx, ops in enumerate(self.circuit.moments):
                for op in ops:
                    self.circuit.batch_remove([(idx, op)])
            self.circuit = cirq.drop_empty_moments(self.circuit)
        except Exception as err:
            print('Remove moments failed.')
        for sg in self.site_groups:
            sg.reset()
        condCounter = 0  # count the index of conditional operation
        if upto is None:
            ops_todo = self.operations
        else:
            ops_todo = self.operations[:upto]
        for op in ops_todo:
            contain_err = getattr(op, 'do_clean', None)
            if error or (not contain_err):
                conditional = getattr(op, 'isConditional', False)
                if conditional:
                    op.do(states=states)
                    condCounter += 1
                else:
                    op.do()
            else:
                op.do_clean()

    def plot_frames(self, frames, axs):
        """ Plot frames specified by indices in frames on axes axs. """
        for f, ax in zip(frames, axs):
            self.do(upto=f + 1)
            for sg in self.site_groups:
                sg.plot(ax)
            ax.set_title('Step %d\n%s' % (f, self.operations[f]))

    def animate_frames(self, frames, outfile, figsize=(3, 10), interval=500):
        fig, ax = plt.subplots(1, 1, figsize=figsize)
        def animate_fn(n):
            self.do(upto=n + 1)
            for sg in self.site_groups:
                sg.plot(ax)
            ax.set_title('Step %d\n%s' % (n, self.operations[n]))
        anim = FuncAnimation(fig, animate_fn, frames=frames, interval=interval, blit=False)
        writergif = animation.PillowWriter(fps=int(1000 / interval))
        anim.save(outfile + '.gif', writer=writergif)

    def to_phase_string(self, upto=None):
        phase_list = []
        if upto is None:
            opesToDo = self.operations
        else:
            opesToDo = self.operations[:upto]
        for op in opesToDo:
            expt = getattr(op, 'expt', None)
            if expt is None:
                continue
            # myPhase = expt['phase'](**expt['args'])
            if isinstance(expt, list):
                phase_list += expt
            else:
                phase_list.append(expt)
        return phase_list

    def to_phase_list(self, modulePhase, module_rfsoc, Params, upto=None):
        # convert phase list generated by array_circuit.to_phase_list to experimental objects
        phaseList = self.to_phase_string(upto=upto)
        objList = []
        for phase in phaseList:
            if phase.args is None:
                myObj = phase.getObject(modulePhase)
            else:
                # convert inner fnArgs into objects
                newArgs = dict(phase.args)
                for k in newArgs.keys():
                    if isinstance(newArgs[k], FnArgs):
                        newArgs[k] = newArgs[k].getObject(module_rfsoc)
                    if isinstance(newArgs[k], str) and newArgs[k][:6] == 'params':
                        newArgs[k] = Params[newArgs[k][8:-2]]
                    if isinstance(newArgs[k], list):
                        for i, ki in enumerate(newArgs[k]):
                            if isinstance(newArgs[k][i], FnArgs):
                                newArgs[k][i] = newArgs[k][i].getObject(module_rfsoc)
                            if isinstance(newArgs[k], str) and newArgs[k][:6] == 'params':
                                newArgs[k][i] = Params[newArgs[k][i][8:-2]]
                newFnArgs = FnArgs(phase.fn, newArgs)
                myObj = newFnArgs.getObject(modulePhase)
            objList.append(myObj)
        return objList
